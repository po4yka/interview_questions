---
id: 20251016-162640
title: "Room Code Generation Timing / Время генерации кода Room"
topic: android
difficulty: medium
status: draft
moc: moc-android
related: [q-dagger-framework-overview--android--hard, q-koin-fundamentals--dependency-injection--medium, q-baseline-profiles-optimization--performance--medium]
created: 2025-10-15
tags: [android/data-storage, annotation-processing, code-generation, compile-time, kapt, ksp, room, difficulty/medium]
---
# В какой момент генерируется код при использовании SQLite?

**English**: When is code generated when using SQLite/Room?

## Answer (EN)
If you use **Room** (ORM for SQLite), code is generated **at compile time** using **Annotation Processing** (**kapt**) or **KSP** (Kotlin Symbol Processing).

**SQLite** itself does not generate code - it's a runtime database library. However, when using **Room** as an abstraction layer over SQLite, Room's annotation processor generates implementation code during compilation.

## Code Generation Process

### 1. Write Room Code with Annotations

```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val email: String
)

@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>

    @Insert
    suspend fun insert(user: User)
}

@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

### 2. Annotation Processor Runs at Compile Time

**Using kapt (Kotlin Annotation Processing Tool):**

```kotlin
// build.gradle
plugins {
    id 'kotlin-kapt'
}

dependencies {
    implementation "androidx.room:room-runtime:2.6.0"
    implementation "androidx.room:room-ktx:2.6.0"
    kapt "androidx.room:room-compiler:2.6.0"  // Annotation processor
}
```

**Or using KSP (Kotlin Symbol Processing - faster):**

```kotlin
// build.gradle
plugins {
    id 'com.google.devtools.ksp' version '1.9.0-1.0.13'
}

dependencies {
    implementation "androidx.room:room-runtime:2.6.0"
    implementation "androidx.room:room-ktx:2.6.0"
    ksp "androidx.room:room-compiler:2.6.0"  // Code generator
}
```

### 3. Generated Code (Example)

Room generates implementation classes based on your annotations:

**Generated DAO Implementation:**

```kotlin
// Auto-generated by Room (simplified)
public class UserDao_Impl implements UserDao {
    private final RoomDatabase __db;
    private final EntityInsertionAdapter<User> __insertionAdapterOfUser;

    public UserDao_Impl(RoomDatabase __db) {
        this.__db = __db;
        this.__insertionAdapterOfUser = new EntityInsertionAdapter<User>(__db) {
            @Override
            public String createQuery() {
                return "INSERT OR ABORT INTO `users` (`id`,`name`,`email`) VALUES (?,?,?)";
            }

            @Override
            public void bind(SupportSQLiteStatement stmt, User value) {
                stmt.bindLong(1, value.id);
                stmt.bindString(2, value.name);
                stmt.bindString(3, value.email);
            }
        };
    }

    @Override
    public Object insert(User user, Continuation<? super Unit> continuation) {
        return CoroutinesRoom.execute(__db, true, new Callable<Unit>() {
            @Override
            public Unit call() throws Exception {
                __db.beginTransaction();
                try {
                    __insertionAdapterOfUser.insert(user);
                    __db.setTransactionSuccessful();
                    return Unit.INSTANCE;
                } finally {
                    __db.endTransaction();
                }
            }
        }, continuation);
    }

    @Override
    public Flow<List<User>> getAllUsers() {
        final String _sql = "SELECT * FROM users";
        final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 0);
        return CoroutinesRoom.createFlow(__db, false, new String[]{"users"},
            new Callable<List<User>>() {
                @Override
                public List<User> call() throws Exception {
                    Cursor _cursor = DBUtil.query(__db, _statement, false, null);
                    try {
                        final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
                        final int _cursorIndexOfName = CursorUtil.getColumnIndexOrThrow(_cursor, "name");
                        final int _cursorIndexOfEmail = CursorUtil.getColumnIndexOrThrow(_cursor, "email");
                        final List<User> _result = new ArrayList<User>(_cursor.getCount());
                        while(_cursor.moveToNext()) {
                            final User _item;
                            final int _tmpId;
                            _tmpId = _cursor.getInt(_cursorIndexOfId);
                            final String _tmpName;
                            _tmpName = _cursor.getString(_cursorIndexOfName);
                            final String _tmpEmail;
                            _tmpEmail = _cursor.getString(_cursorIndexOfEmail);
                            _item = new User(_tmpId, _tmpName, _tmpEmail);
                            _result.add(_item);
                        }
                        return _result;
                    } finally {
                        _cursor.close();
                    }
                }
            });
    }
}
```

**Location of generated files:**

```
app/build/generated/
   ksp/          # If using KSP
      kotlin/
          UserDao_Impl.kt
   source/kapt/  # If using kapt
       debug/
           UserDao_Impl.java
```

---

## Compile-Time Validation

Room validates SQL queries **at compile time**, catching errors early:

**Example - SQL Error Caught at Compile Time:**

```kotlin
@Dao
interface UserDao {
    // - Compile error: Table "usres" doesn't exist (typo!)
    @Query("SELECT * FROM usres")
    fun getAllUsers(): Flow<List<User>>

    // - Compile error: Column "age" doesn't exist in User entity
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): List<User>
}
```

**Compiler output:**

```
error: There is a problem with the query: [SQLITE_ERROR] SQL error or missing database (no such table: usres)
SELECT * FROM usres
             ^
```

---

## kapt vs KSP Comparison

### kapt (Kotlin Annotation Processing Tool)

**Characteristics:**
- Uses Java annotation processing API
- Slower (requires stub generation)
- More mature, widely supported

**Example:**

```kotlin
// build.gradle
plugins {
    id 'kotlin-kapt'
}

dependencies {
    kapt "androidx.room:room-compiler:2.6.0"
}
```

**Build time:** ~30-60 seconds (depends on project size)

---

### KSP (Kotlin Symbol Processing)

**Characteristics:**
- Native Kotlin API
- Up to 2x faster than kapt
- Modern, recommended for new projects

**Example:**

```kotlin
// build.gradle (project)
plugins {
    id 'com.google.devtools.ksp' version '1.9.0-1.0.13' apply false
}

// build.gradle (app)
plugins {
    id 'com.google.devtools.ksp'
}

dependencies {
    ksp "androidx.room:room-compiler:2.6.0"
}
```

**Build time:** ~15-30 seconds (up to 2x faster)

---

## Compilation Stages

```
1. Write Kotlin code with Room annotations
   ↓
2. Compile-time annotation processing (kapt/KSP)
   - Validates SQL queries
   - Generates DAO implementations
   - Generates Database implementations
   ↓
3. Generated code compiled to bytecode
   ↓
4. Runtime: Use generated implementations
```

**Example timeline:**

```kotlin
// Stage 1: You write
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAll(): List<User>
}

// Stage 2: Compile-time - Room generates
class UserDao_Impl : UserDao {
    override fun getAll(): List<User> {
        // Generated implementation
    }
}

// Stage 3: Compilation to bytecode

// Stage 4: Runtime usage
val dao = database.userDao()  // Returns UserDao_Impl instance
val users = dao.getAll()       // Calls generated code
```

---

## Incremental Compilation

**KSP supports incremental compilation:**

```kotlin
// Only reprocesses changed files
@Entity
data class User(...)  // Changed

@Entity
data class Product(...)  // Unchanged - not reprocessed!
```

**Benefits:**
- - Faster builds (only changed files)
- - Better IDE performance
- - Reduced compilation time

---

## Debugging Generated Code

**View generated code in Android Studio:**

1. Build project: `Build → Rebuild Project`
2. Navigate to generated files:
   - **kapt**: `app/build/generated/source/kapt/debug/`
   - **KSP**: `app/build/generated/ksp/debug/kotlin/`

**Example path:**

```
app/build/generated/ksp/debug/kotlin/
 com/example/app/database/
     UserDao_Impl.kt
     AppDatabase_Impl.kt
     User_Dao_Impl.kt
```

---

## Performance Comparison

| Aspect | kapt | KSP |
|--------|------|-----|
| **Speed** | Slower | 2x faster - |
| **API** | Java | Kotlin - |
| **Incremental** | Limited | Full - |
| **Maturity** | Mature | Modern - |
| **Room Support** | Full | Full - |

**Recommendation:** Use **KSP** for new projects (faster, better Kotlin support)

---

## Summary

**When does code generation happen?**
- - **Compile time** (not runtime!)
- - Using **kapt** or **KSP** annotation processors
- - Generates DAO implementations, Database implementations
- - Validates SQL queries at compile time
- - Errors caught during compilation, not at runtime

**Process:**
1. Write Room annotations (`@Entity`, `@Dao`, `@Query`)
2. Run build (kapt/KSP processes annotations)
3. Code generated in `build/generated/`
4. Generated code compiled with your app
5. Runtime: Use generated implementations

**SQLite itself:** No code generation (runtime library)

**Room over SQLite:** Generates code at compile time via kapt/KSP

## Ответ (RU)

Если используешь **Room** (ORM для SQLite), код генерируется **на этапе компиляции** с помощью **Annotation Processing** (**kapt**) или **KSP** (Kotlin Symbol Processing).

**SQLite** сам по себе не генерирует код - это библиотека для работы с базами данных во время выполнения. Однако при использовании **Room** как слоя абстракции над SQLite, процессор аннотаций Room генерирует код реализации во время компиляции.

## Процесс Генерации Кода

### 1. Написание Кода Room с Аннотациями

```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val email: String
)

@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>

    @Insert
    suspend fun insert(user: User)
}

@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

### 2. Процессор Аннотаций Запускается на Этапе Компиляции

**Использование kapt (Kotlin Annotation Processing Tool):**

```kotlin
// build.gradle
plugins {
    id 'kotlin-kapt'
}

dependencies {
    implementation "androidx.room:room-runtime:2.6.0"
    implementation "androidx.room:room-ktx:2.6.0"
    kapt "androidx.room:room-compiler:2.6.0"  // Процессор аннотаций
}
```

**Или использование KSP (Kotlin Symbol Processing - быстрее):**

```kotlin
// build.gradle
plugins {
    id 'com.google.devtools.ksp' version '1.9.0-1.0.13'
}

dependencies {
    implementation "androidx.room:room-runtime:2.6.0"
    implementation "androidx.room:room-ktx:2.6.0"
    ksp "androidx.room:room-compiler:2.6.0"  // Генератор кода
}
```

### 3. Сгенерированный Код (Пример)

Room генерирует классы реализации на основе ваших аннотаций:

**Сгенерированная Реализация DAO:**

```kotlin
// Автоматически сгенерировано Room (упрощённо)
public class UserDao_Impl implements UserDao {
    private final RoomDatabase __db;
    private final EntityInsertionAdapter<User> __insertionAdapterOfUser;

    public UserDao_Impl(RoomDatabase __db) {
        this.__db = __db;
        this.__insertionAdapterOfUser = new EntityInsertionAdapter<User>(__db) {
            @Override
            public String createQuery() {
                return "INSERT OR ABORT INTO `users` (`id`,`name`,`email`) VALUES (?,?,?)";
            }

            @Override
            public void bind(SupportSQLiteStatement stmt, User value) {
                stmt.bindLong(1, value.id);
                stmt.bindString(2, value.name);
                stmt.bindString(3, value.email);
            }
        };
    }

    @Override
    public Object insert(User user, Continuation<? super Unit> continuation) {
        return CoroutinesRoom.execute(__db, true, new Callable<Unit>() {
            @Override
            public Unit call() throws Exception {
                __db.beginTransaction();
                try {
                    __insertionAdapterOfUser.insert(user);
                    __db.setTransactionSuccessful();
                    return Unit.INSTANCE;
                } finally {
                    __db.endTransaction();
                }
            }
        }, continuation);
    }

    @Override
    public Flow<List<User>> getAllUsers() {
        final String _sql = "SELECT * FROM users";
        final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 0);
        return CoroutinesRoom.createFlow(__db, false, new String[]{"users"},
            new Callable<List<User>>() {
                @Override
                public List<User> call() throws Exception {
                    Cursor _cursor = DBUtil.query(__db, _statement, false, null);
                    try {
                        // Чтение данных из курсора
                        final List<User> _result = new ArrayList<>();
                        while(_cursor.moveToNext()) {
                            final User _item = new User(
                                _cursor.getInt(0),
                                _cursor.getString(1),
                                _cursor.getString(2)
                            );
                            _result.add(_item);
                        }
                        return _result;
                    } finally {
                        _cursor.close();
                    }
                }
            });
    }
}
```

**Расположение сгенерированных файлов:**

```
app/build/generated/
   ksp/          # Если используется KSP
      kotlin/
          UserDao_Impl.kt
   source/kapt/  # Если используется kapt
       debug/
           UserDao_Impl.java
```

---

## Валидация на Этапе Компиляции

Room валидирует SQL-запросы **на этапе компиляции**, обнаруживая ошибки заранее:

**Пример - SQL Ошибка Обнаружена на Этапе Компиляции:**

```kotlin
@Dao
interface UserDao {
    // Ошибка компиляции: Таблица "usres" не существует (опечатка!)
    @Query("SELECT * FROM usres")
    fun getAllUsers(): Flow<List<User>>

    // Ошибка компиляции: Колонка "age" не существует в сущности User
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): List<User>
}
```

**Вывод компилятора:**

```
error: There is a problem with the query: [SQLITE_ERROR] SQL error or missing database (no such table: usres)
SELECT * FROM usres
             ^
```

---

## Сравнение kapt vs KSP

### kapt (Kotlin Annotation Processing Tool)

**Характеристики:**
- Использует Java API для обработки аннотаций
- Медленнее (требует генерации stubs)
- Более зрелый, широко поддерживается

**Пример:**

```kotlin
// build.gradle
plugins {
    id 'kotlin-kapt'
}

dependencies {
    kapt "androidx.room:room-compiler:2.6.0"
}
```

**Время сборки:** ~30-60 секунд (зависит от размера проекта)

---

### KSP (Kotlin Symbol Processing)

**Характеристики:**
- Нативный Kotlin API
- До 2x быстрее чем kapt
- Современный, рекомендуется для новых проектов

**Пример:**

```kotlin
// build.gradle (project)
plugins {
    id 'com.google.devtools.ksp' version '1.9.0-1.0.13' apply false
}

// build.gradle (app)
plugins {
    id 'com.google.devtools.ksp'
}

dependencies {
    ksp "androidx.room:room-compiler:2.6.0"
}
```

**Время сборки:** ~15-30 секунд (до 2x быстрее)

---

## Стадии Компиляции

```
1. Написание Kotlin кода с аннотациями Room
   ↓
2. Обработка аннотаций на этапе компиляции (kapt/KSP)
   - Валидация SQL-запросов
   - Генерация реализаций DAO
   - Генерация реализаций Database
   ↓
3. Сгенерированный код компилируется в байткод
   ↓
4. Runtime: Использование сгенерированных реализаций
```

**Пример временной линии:**

```kotlin
// Стадия 1: Вы пишете
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAll(): List<User>
}

// Стадия 2: Время компиляции - Room генерирует
class UserDao_Impl : UserDao {
    override fun getAll(): List<User> {
        // Сгенерированная реализация
    }
}

// Стадия 3: Компиляция в байткод

// Стадия 4: Использование во время выполнения
val dao = database.userDao()  // Возвращает экземпляр UserDao_Impl
val users = dao.getAll()       // Вызывает сгенерированный код
```

---

## Инкрементальная Компиляция

**KSP поддерживает инкрементальную компиляцию:**

```kotlin
// Обрабатываются только изменённые файлы
@Entity
data class User(...)  // Изменён

@Entity
data class Product(...)  // Не изменён - не обрабатывается!
```

**Преимущества:**
- Более быстрые сборки (только изменённые файлы)
- Лучшая производительность IDE
- Сокращённое время компиляции

---

## Отладка Сгенерированного Кода

**Просмотр сгенерированного кода в Android Studio:**

1. Собрать проект: `Build → Rebuild Project`
2. Перейти к сгенерированным файлам:
   - **kapt**: `app/build/generated/source/kapt/debug/`
   - **KSP**: `app/build/generated/ksp/debug/kotlin/`

**Пример пути:**

```
app/build/generated/ksp/debug/kotlin/
 com/example/app/database/
     UserDao_Impl.kt
     AppDatabase_Impl.kt
```

---

## Сравнение Производительности

| Аспект | kapt | KSP |
|--------|------|-----|
| **Скорость** | Медленнее | В 2 раза быстрее |
| **API** | Java | Kotlin |
| **Инкрементальность** | Ограниченная | Полная |
| **Зрелость** | Зрелый | Современный |
| **Поддержка Room** | Полная | Полная |

**Рекомендация:** Используйте **KSP** для новых проектов (быстрее, лучшая поддержка Kotlin)

---

## Резюме

**Когда происходит генерация кода?**
- **Время компиляции** (не во время выполнения!)
- Используя процессоры аннотаций **kapt** или **KSP**
- Генерирует реализации DAO, реализации Database
- Валидирует SQL-запросы на этапе компиляции
- Ошибки обнаруживаются во время компиляции, а не во время выполнения

**Процесс:**
1. Написать аннотации Room (`@Entity`, `@Dao`, `@Query`)
2. Запустить сборку (kapt/KSP обрабатывает аннотации)
3. Код генерируется в `build/generated/`
4. Сгенерированный код компилируется с вашим приложением
5. Runtime: Использование сгенерированных реализаций

**SQLite сам по себе:** Не генерирует код (библиотека времени выполнения)

**Room над SQLite:** Генерирует код на этапе компиляции через kapt/KSP


---

## Related Questions

### Prerequisites (Easier)
- [[q-sharedpreferences-commit-vs-apply--android--easy]] - Storage
- [[q-room-library-definition--android--easy]] - Storage

### Related (Medium)
- [[q-room-transactions-dao--room--medium]] - Storage
- [[q-room-paging3-integration--room--medium]] - Storage
- [[q-room-type-converters-advanced--room--medium]] - Storage
- [[q-room-vs-sqlite--android--medium]] - Storage
- [[q-room-type-converters--android--medium]] - Storage

### Advanced (Harder)
- [[q-room-fts-full-text-search--room--hard]] - Storage
