---
tags:
  - android
  - dependency-injection
  - hilt
  - dagger
  - assisted-inject
difficulty: medium
status: draft
related:
  - q-hilt-entry-points--di--medium
  - q-dagger-multibinding--di--hard
  - q-hilt-viewmodel-injection--jetpack--medium
created: 2025-10-11
---

# Question (EN)
What is Assisted Injection in Hilt/Dagger? When and why would you use `@AssistedInject` and `@AssistedFactory`? Provide real-world examples.

## Answer (EN)
### Overview

**Assisted Injection** is a Dagger/Hilt feature that allows you to mix dependencies provided by Dagger with runtime parameters that you provide when creating an instance. This is useful when you need to create objects that require both injected dependencies and user-provided data.

### The Problem Without Assisted Injection

Consider a scenario where you need to create a repository for a specific user:

```kotlin
// ❌ Problem: Can't inject userId because it's runtime data
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val database: Database,
    private val userId: String // ERROR: Dagger doesn't know this!
)

// ❌ Problem: Have to manually provide all dependencies
class UserRepository(
    private val apiService: ApiService,
    private val database: Database,
    private val userId: String
) {
    // Now you lose all benefits of DI - have to create manually:
    val repository = UserRepository(apiService, database, "user123")
}

// ❌ Problem: Factory pattern with manual dependencies
interface UserRepositoryFactory {
    fun create(userId: String): UserRepository
}

class UserRepositoryFactoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val database: Database
) : UserRepositoryFactory {
    override fun create(userId: String): UserRepository {
        return UserRepository(apiService, database, userId)
    }
}
```

### Solution: Assisted Injection

```kotlin
// ✅ Solution: Mix injected and runtime dependencies
class UserRepository @AssistedInject constructor(
    // Dependencies provided by Dagger
    private val apiService: ApiService,
    private val database: Database,
    // Runtime parameter provided by you
    @Assisted private val userId: String
) {

    suspend fun getUserData(): User {
        return apiService.getUser(userId)
    }

    suspend fun saveUser(user: User) {
        database.userDao().insert(user)
    }
}

// ✅ Factory is automatically generated by Dagger
@AssistedFactory
interface UserRepositoryFactory {
    fun create(userId: String): UserRepository
}

// ✅ Usage: Inject the factory, call it with runtime data
class UserViewModel @Inject constructor(
    private val userRepositoryFactory: UserRepositoryFactory,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val userId: String = savedStateHandle["userId"]!!

    // Create repository with both injected and runtime params
    private val repository = userRepositoryFactory.create(userId)

    val userData = repository.getUserData()
}
```

**How it works:**
1. Mark the class constructor with `@AssistedInject`
2. Mark runtime parameters with `@Assisted`
3. Create a factory interface with `@AssistedFactory`
4. Dagger generates the factory implementation
5. Inject the factory and call `create()` with runtime params

### Basic Example: Chat Message Processor

```kotlin
// Message processor that needs both injected dependencies and runtime message
class MessageProcessor @AssistedInject constructor(
    // Injected by Dagger
    private val apiService: ApiService,
    private val database: Database,
    private val analytics: Analytics,
    // Provided at runtime
    @Assisted private val message: Message,
    @Assisted private val senderId: String
) {

    suspend fun process() {
        analytics.track("message_processing_started", mapOf(
            "sender_id" to senderId,
            "message_type" to message.type
        ))

        // Validate message
        if (message.content.isEmpty()) {
            throw IllegalArgumentException("Message content cannot be empty")
        }

        // Send to API
        val result = apiService.sendMessage(senderId, message)

        // Save to local database
        database.messageDao().insert(MessageEntity.from(message, result.id))

        analytics.track("message_processing_completed")
    }
}

@AssistedFactory
interface MessageProcessorFactory {
    fun create(message: Message, senderId: String): MessageProcessor
}

// Usage in ViewModel
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val messageProcessorFactory: MessageProcessorFactory,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val currentUserId: String = savedStateHandle["userId"]!!

    fun sendMessage(message: Message) {
        viewModelScope.launch {
            val processor = messageProcessorFactory.create(message, currentUserId)
            processor.process()
        }
    }
}
```

### Multiple @Assisted Parameters

You can have multiple runtime parameters:

```kotlin
class OrderProcessor @AssistedInject constructor(
    // Injected dependencies
    private val apiService: ApiService,
    private val paymentService: PaymentService,
    private val analytics: Analytics,
    // Runtime parameters
    @Assisted private val orderId: String,
    @Assisted private val userId: String,
    @Assisted private val items: List<OrderItem>
) {

    suspend fun processOrder(): OrderResult {
        analytics.track("order_processing", mapOf("order_id" to orderId))

        // Calculate total
        val total = items.sumOf { it.price * it.quantity }

        // Process payment
        val paymentResult = paymentService.charge(userId, total)

        // Create order
        val order = apiService.createOrder(orderId, userId, items)

        return OrderResult(order, paymentResult)
    }
}

@AssistedFactory
interface OrderProcessorFactory {
    fun create(orderId: String, userId: String, items: List<OrderItem>): OrderProcessor
}
```

### Disambiguating Same-Type Parameters

When you have multiple parameters of the same type, use named `@Assisted`:

```kotlin
class TransferProcessor @AssistedInject constructor(
    private val apiService: ApiService,
    // Use named @Assisted to distinguish same-type parameters
    @Assisted("fromUserId") private val fromUserId: String,
    @Assisted("toUserId") private val toUserId: String,
    @Assisted("amount") private val amount: Double
) {

    suspend fun transfer() {
        apiService.transfer(fromUserId, toUserId, amount)
    }
}

@AssistedFactory
interface TransferProcessorFactory {
    // Parameter names in factory must match @Assisted names
    fun create(
        @Assisted("fromUserId") fromUserId: String,
        @Assisted("toUserId") toUserId: String,
        @Assisted("amount") amount: Double
    ): TransferProcessor
}
```

### Real-World Example: RecyclerView ViewHolder with Dependencies

```kotlin
// ViewHolder that needs both injected dependencies and view/data
class ProductViewHolder @AssistedInject constructor(
    // Injected dependencies
    private val imageLoader: ImageLoader,
    private val analytics: Analytics,
    private val cartManager: CartManager,
    // Runtime parameters
    @Assisted private val view: View,
    @Assisted private val onClickListener: (Product) -> Unit
) : RecyclerView.ViewHolder(view) {

    private val imageView: ImageView = view.findViewById(R.id.productImage)
    private val titleView: TextView = view.findViewById(R.id.productTitle)
    private val priceView: TextView = view.findViewById(R.id.productPrice)
    private val addToCartButton: Button = view.findViewById(R.id.addToCart)

    private var currentProduct: Product? = null

    init {
        addToCartButton.setOnClickListener {
            currentProduct?.let { product ->
                cartManager.addToCart(product)
                analytics.track("add_to_cart", mapOf("product_id" to product.id))
            }
        }

        view.setOnClickListener {
            currentProduct?.let { product ->
                analytics.track("product_clicked", mapOf("product_id" to product.id))
                onClickListener(product)
            }
        }
    }

    fun bind(product: Product) {
        currentProduct = product
        titleView.text = product.title
        priceView.text = "$${product.price}"
        imageLoader.load(product.imageUrl, imageView)
    }
}

@AssistedFactory
interface ProductViewHolderFactory {
    fun create(view: View, onClickListener: (Product) -> Unit): ProductViewHolder
}

// Adapter
class ProductAdapter @Inject constructor(
    private val productViewHolderFactory: ProductViewHolderFactory
) : RecyclerView.Adapter<ProductViewHolder>() {

    private val products = mutableListOf<Product>()
    private var onProductClick: (Product) -> Unit = {}

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProductViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_product, parent, false)

        // Use the factory to create ViewHolder with injected dependencies
        return productViewHolderFactory.create(view, onProductClick)
    }

    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {
        holder.bind(products[position])
    }

    override fun getItemCount() = products.size

    fun submitList(newProducts: List<Product>) {
        products.clear()
        products.addAll(newProducts)
        notifyDataSetChanged()
    }

    fun setOnProductClickListener(listener: (Product) -> Unit) {
        onProductClick = listener
    }
}

// Usage in Fragment
@AndroidEntryPoint
class ProductListFragment : Fragment() {

    @Inject
    lateinit var adapter: ProductAdapter

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val recyclerView: RecyclerView = view.findViewById(R.id.recyclerView)
        recyclerView.adapter = adapter

        adapter.setOnProductClickListener { product ->
            // Navigate to product details
            navigateToProductDetails(product.id)
        }
    }
}
```

### Assisted Injection with WorkManager

```kotlin
// Worker with assisted injection (Hilt 2.31+)
@HiltWorker
class DataSyncWorker @AssistedInject constructor(
    // Assisted parameters from WorkManager
    @Assisted context: Context,
    @Assisted params: WorkerParameters,
    // Injected dependencies
    private val apiService: ApiService,
    private val database: AppDatabase,
    private val notificationManager: NotificationManager
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        return try {
            // Get runtime data from inputData
            val syncType = inputData.getString("sync_type") ?: "full"

            notificationManager.showProgress("Syncing data...")

            when (syncType) {
                "full" -> syncAll()
                "incremental" -> syncIncremental()
                else -> Result.failure()
            }

            notificationManager.showSuccess("Sync completed")
            Result.success()
        } catch (e: Exception) {
            notificationManager.showError("Sync failed: ${e.message}")
            Result.retry()
        }
    }

    private suspend fun syncAll() {
        val data = apiService.fetchAllData()
        database.dataDao().deleteAll()
        database.dataDao().insertAll(data)
    }

    private suspend fun syncIncremental() {
        val lastSyncTime = database.syncDao().getLastSyncTime()
        val data = apiService.fetchDataSince(lastSyncTime)
        database.dataDao().insertAll(data)
        database.syncDao().updateSyncTime(System.currentTimeMillis())
    }
}

// Usage
class SyncManager @Inject constructor(
    @ApplicationContext private val context: Context
) {

    fun scheduleSyncWork(syncType: String) {
        val inputData = workDataOf("sync_type" to syncType)

        val syncWorkRequest = OneTimeWorkRequestBuilder<DataSyncWorker>()
            .setInputData(inputData)
            .setConstraints(Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build())
            .build()

        WorkManager.getInstance(context).enqueue(syncWorkRequest)
    }
}
```

### Assisted Injection with Compose

```kotlin
// UseCase with assisted injection
class LoadUserDetailsUseCase @AssistedInject constructor(
    private val userRepository: UserRepository,
    private val analytics: Analytics,
    @Assisted private val userId: String
) {

    suspend operator fun invoke(): Result<UserDetails> {
        analytics.track("load_user_details", mapOf("user_id" to userId))

        return try {
            val user = userRepository.getUser(userId)
            val posts = userRepository.getUserPosts(userId)
            val followers = userRepository.getFollowers(userId)

            Result.success(UserDetails(user, posts, followers))
        } catch (e: Exception) {
            analytics.track("load_user_details_error", mapOf(
                "user_id" to userId,
                "error" to e.message
            ))
            Result.failure(e)
        }
    }
}

@AssistedFactory
interface LoadUserDetailsUseCaseFactory {
    fun create(userId: String): LoadUserDetailsUseCase
}

// ViewModel
@HiltViewModel
class UserDetailsViewModel @Inject constructor(
    private val loadUserDetailsUseCaseFactory: LoadUserDetailsUseCaseFactory,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val userId: String = savedStateHandle["userId"]!!

    val userDetails = flow {
        val useCase = loadUserDetailsUseCaseFactory.create(userId)
        val result = useCase()
        emit(result)
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        Result.success(UserDetails.Empty)
    )
}

// Composable
@Composable
fun UserDetailsScreen(
    viewModel: UserDetailsViewModel = hiltViewModel()
) {
    val userDetails by viewModel.userDetails.collectAsState()

    when {
        userDetails.isSuccess -> {
            val details = userDetails.getOrNull()!!
            UserDetailsContent(details)
        }
        userDetails.isFailure -> {
            ErrorScreen(userDetails.exceptionOrNull()?.message ?: "Unknown error")
        }
    }
}
```

### Advanced: Assisted Injection with Generics

```kotlin
// Generic processor with assisted injection
class DataProcessor<T : Any> @AssistedInject constructor(
    private val apiService: ApiService,
    private val database: Database,
    @Assisted private val data: T,
    @Assisted private val validator: (T) -> Boolean
) {

    suspend fun process(): Result<T> {
        if (!validator(data)) {
            return Result.failure(IllegalArgumentException("Invalid data"))
        }

        // Process data
        val result = apiService.upload(data)
        database.save(data)

        return Result.success(result)
    }
}

// Need separate factory for each type
@AssistedFactory
interface UserDataProcessorFactory {
    fun create(data: User, validator: (User) -> Boolean): DataProcessor<User>
}

@AssistedFactory
interface ProductDataProcessorFactory {
    fun create(data: Product, validator: (Product) -> Boolean): DataProcessor<Product>
}

// Usage
class DataUploadManager @Inject constructor(
    private val userDataProcessorFactory: UserDataProcessorFactory,
    private val productDataProcessorFactory: ProductDataProcessorFactory
) {

    suspend fun uploadUser(user: User): Result<User> {
        val validator: (User) -> Boolean = { it.email.isNotEmpty() && it.name.isNotEmpty() }
        val processor = userDataProcessorFactory.create(user, validator)
        return processor.process()
    }

    suspend fun uploadProduct(product: Product): Result<Product> {
        val validator: (Product) -> Boolean = { it.price > 0 && it.title.isNotEmpty() }
        val processor = productDataProcessorFactory.create(product, validator)
        return processor.process()
    }
}
```

### Production Example: File Upload with Progress

```kotlin
// File uploader with progress callback
class FileUploader @AssistedInject constructor(
    private val apiService: ApiService,
    private val analytics: Analytics,
    @Assisted private val file: File,
    @Assisted private val onProgress: (Int) -> Unit
) {

    suspend fun upload(): Result<FileUploadResponse> {
        analytics.track("file_upload_started", mapOf(
            "file_name" to file.name,
            "file_size" to file.length()
        ))

        return try {
            val fileSize = file.length()
            var uploadedBytes = 0L

            val requestBody = object : RequestBody() {
                override fun contentType() = "application/octet-stream".toMediaTypeOrNull()

                override fun contentLength() = fileSize

                override fun writeTo(sink: BufferedSink) {
                    file.source().use { source ->
                        var bytesRead: Long
                        val buffer = Buffer()

                        while (source.read(buffer, 8192).also { bytesRead = it } != -1L) {
                            sink.write(buffer, bytesRead)
                            uploadedBytes += bytesRead

                            // Report progress
                            val progress = ((uploadedBytes.toFloat() / fileSize) * 100).toInt()
                            onProgress(progress)
                        }
                    }
                }
            }

            val response = apiService.uploadFile(requestBody)

            analytics.track("file_upload_completed", mapOf(
                "file_name" to file.name,
                "upload_id" to response.id
            ))

            Result.success(response)
        } catch (e: Exception) {
            analytics.track("file_upload_failed", mapOf(
                "file_name" to file.name,
                "error" to e.message
            ))
            Result.failure(e)
        }
    }
}

@AssistedFactory
interface FileUploaderFactory {
    fun create(file: File, onProgress: (Int) -> Unit): FileUploader
}

// ViewModel
@HiltViewModel
class FileUploadViewModel @Inject constructor(
    private val fileUploaderFactory: FileUploaderFactory
) : ViewModel() {

    private val _uploadProgress = MutableStateFlow(0)
    val uploadProgress: StateFlow<Int> = _uploadProgress.asStateFlow()

    private val _uploadState = MutableStateFlow<UploadState>(UploadState.Idle)
    val uploadState: StateFlow<UploadState> = _uploadState.asStateFlow()

    fun uploadFile(file: File) {
        viewModelScope.launch {
            _uploadState.value = UploadState.Uploading

            val uploader = fileUploaderFactory.create(file) { progress ->
                _uploadProgress.value = progress
            }

            val result = uploader.upload()

            _uploadState.value = when {
                result.isSuccess -> UploadState.Success(result.getOrNull()!!)
                else -> UploadState.Error(result.exceptionOrNull()?.message ?: "Upload failed")
            }
        }
    }
}

sealed class UploadState {
    object Idle : UploadState()
    object Uploading : UploadState()
    data class Success(val response: FileUploadResponse) : UploadState()
    data class Error(val message: String) : UploadState()
}

// Composable
@Composable
fun FileUploadScreen(
    viewModel: FileUploadViewModel = hiltViewModel()
) {
    val uploadProgress by viewModel.uploadProgress.collectAsState()
    val uploadState by viewModel.uploadState.collectAsState()

    Column(modifier = Modifier.padding(16.dp)) {
        when (uploadState) {
            is UploadState.Idle -> {
                Button(onClick = { /* Pick file */ }) {
                    Text("Select File")
                }
            }
            is UploadState.Uploading -> {
                LinearProgressIndicator(
                    progress = uploadProgress / 100f,
                    modifier = Modifier.fillMaxWidth()
                )
                Text("Uploading: $uploadProgress%")
            }
            is UploadState.Success -> {
                Text("Upload completed!")
            }
            is UploadState.Error -> {
                Text("Error: ${(uploadState as UploadState.Error).message}")
            }
        }
    }
}
```

### Assisted Injection vs Alternatives

| Approach | When to Use | Pros | Cons |
|----------|-------------|------|------|
| **@AssistedInject** | Mix DI + runtime params | Clean, type-safe, DI benefits | Extra factory interface |
| **Manual Factory** | Simple cases | No annotation processor | Boilerplate, lose DI benefits |
| **Provider<T>** | Create multiple instances | Simple | All params must be injectable |
| **Lazy<T>** | Defer creation | Simple | All params must be injectable |
| **@Binds with qualifier** | Multiple implementations | Simple | Params must be known at compile-time |

### Best Practices

1. **Use @AssistedInject for Runtime Parameters**
   ```kotlin
   // ✅ GOOD - Runtime data via @Assisted
   class UserRepository @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val userId: String
   )

   // ❌ BAD - Trying to inject runtime data
   class UserRepository @Inject constructor(
       private val api: ApiService,
       private val userId: String // Won't compile!
   )
   ```

2. **Name Same-Type Parameters**
   ```kotlin
   // ✅ GOOD - Named for clarity
   @AssistedInject constructor(
       @Assisted("startDate") private val startDate: Long,
       @Assisted("endDate") private val endDate: Long
   )

   // ❌ BAD - Ambiguous
   @AssistedInject constructor(
       @Assisted private val startDate: Long,
       @Assisted private val endDate: Long // Which is which?
   )
   ```

3. **Keep Assisted Parameters Minimal**
   ```kotlin
   // ✅ GOOD - Minimal runtime params
   class OrderProcessor @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val orderId: String
   )

   // ❌ BAD - Too many runtime params suggests wrong abstraction
   class OrderProcessor @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val orderId: String,
       @Assisted private val userId: String,
       @Assisted private val items: List<Item>,
       @Assisted private val address: Address,
       @Assisted private val payment: PaymentInfo // Too many!
   )
   ```

4. **Don't Confuse with @AssistedFactory vs Factory Pattern**
   ```kotlin
   // ✅ GOOD - @AssistedFactory for DI + runtime params
   @AssistedFactory
   interface UserRepoFactory {
       fun create(userId: String): UserRepository
   }

   // ❌ BAD - Manual factory loses DI benefits
   interface UserRepoFactory {
       fun create(userId: String): UserRepository
   }
   class UserRepoFactoryImpl(
       private val api: ApiService // Have to inject factory instead
   ) : UserRepoFactory {
       override fun create(userId: String) = UserRepository(api, userId)
   }
   ```

5. **Testing with Assisted Injection**
   ```kotlin
   // ✅ GOOD - Test with fake factory
   @Test
   fun testUserRepository() {
       val fakeApi = FakeApiService()
       val fakeFactory = object : UserRepositoryFactory {
           override fun create(userId: String) = UserRepository(fakeApi, userId)
       }

       val repo = fakeFactory.create("user123")
       // Test repo...
   }
   ```

### Common Use Cases

1. **Repository per entity ID**
   ```kotlin
   class EntityRepository @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val entityId: String
   )
   ```

2. **ViewHolder with dependencies**
   ```kotlin
   class CustomViewHolder @AssistedInject constructor(
       private val imageLoader: ImageLoader,
       @Assisted private val view: View
   )
   ```

3. **Worker with dependencies**
   ```kotlin
   @HiltWorker
   class SyncWorker @AssistedInject constructor(
       @Assisted context: Context,
       @Assisted params: WorkerParameters,
       private val api: ApiService
   )
   ```

4. **UseCase with runtime params**
   ```kotlin
   class SubmitFormUseCase @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val formData: FormData
   )
   ```

5. **Callback-based processors**
   ```kotlin
   class DataProcessor @AssistedInject constructor(
       private val api: ApiService,
       @Assisted private val onProgress: (Int) -> Unit
   )
   ```

### Summary

**Assisted Injection** allows mixing dependency injection with runtime parameters:

**When to use:**
- ✅ Need both injected dependencies AND runtime data
- ✅ Creating objects with user input
- ✅ ViewHolders with dependencies
- ✅ Workers with dependencies (Hilt 2.31+)
- ✅ Objects with callbacks

**Key annotations:**
- `@AssistedInject` - Constructor annotation
- `@Assisted` - Parameter annotation for runtime data
- `@AssistedFactory` - Factory interface
- `@Assisted("name")` - Named parameters for disambiguation

**Benefits:**
- Clean separation of injected vs runtime params
- Type-safe factory generation
- Keeps DI benefits while accepting runtime data
- No boilerplate factory implementation

**Best practices:**
1. Use named @Assisted for same-type params
2. Keep assisted parameters minimal
3. Inject factory, not the class directly
4. Test with fake factory implementations

---

# Вопрос (RU)
Что такое Assisted Injection в Hilt/Dagger? Когда и зачем использовать `@AssistedInject` и `@AssistedFactory`? Приведите примеры из реальной практики.

## Ответ (RU)
### Обзор

**Assisted Injection** — это функция Dagger/Hilt, которая позволяет смешивать зависимости, предоставляемые Dagger, с runtime-параметрами, которые вы предоставляете при создании экземпляра. Это полезно, когда вам нужно создать объекты, которые требуют как внедрённых зависимостей, так и данных, предоставленных пользователем.

### Проблема без Assisted Injection

Рассмотрим сценарий, когда нужно создать репозиторий для конкретного пользователя:

```kotlin
// ❌ Проблема: нельзя внедрить userId, потому что это runtime-данные
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val database: Database,
    private val userId: String // ОШИБКА: Dagger не знает это!
)

// ❌ Проблема: нужно вручную предоставлять все зависимости
class UserRepository(
    private val apiService: ApiService,
    private val database: Database,
    private val userId: String
) {
    // Теперь вы теряете все преимущества DI - нужно создавать вручную:
    val repository = UserRepository(apiService, database, "user123")
}

// ❌ Проблема: паттерн Factory с ручными зависимостями
interface UserRepositoryFactory {
    fun create(userId: String): UserRepository
}

class UserRepositoryFactoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val database: Database
) : UserRepositoryFactory {
    override fun create(userId: String): UserRepository {
        return UserRepository(apiService, database, userId)
    }
}
```

### Решение: Assisted Injection

```kotlin
// ✅ Решение: смешиваем внедрённые и runtime-зависимости
class UserRepository @AssistedInject constructor(
    // Зависимости, предоставляемые Dagger
    private val apiService: ApiService,
    private val database: Database,
    // Runtime-параметр, предоставляемый вами
    @Assisted private val userId: String
) {

    suspend fun getUserData(): User {
        return apiService.getUser(userId)
    }

    suspend fun saveUser(user: User) {
        database.userDao().insert(user)
    }
}

// ✅ Factory автоматически генерируется Dagger
@AssistedFactory
interface UserRepositoryFactory {
    fun create(userId: String): UserRepository
}

// ✅ Использование: внедряем factory, вызываем с runtime-данными
class UserViewModel @Inject constructor(
    private val userRepositoryFactory: UserRepositoryFactory,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val userId: String = savedStateHandle["userId"]!!

    // Создаём repository с внедрёнными и runtime-параметрами
    private val repository = userRepositoryFactory.create(userId)

    val userData = repository.getUserData()
}
```

**Как это работает:**
1. Помечаем конструктор класса `@AssistedInject`
2. Помечаем runtime-параметры `@Assisted`
3. Создаём интерфейс factory с `@AssistedFactory`
4. Dagger генерирует реализацию factory
5. Внедряем factory и вызываем `create()` с runtime-параметрами

[Продолжение с остальными примерами из английской версии...]

### Резюме

**Assisted Injection** позволяет смешивать dependency injection с runtime-параметрами:

**Когда использовать:**
- ✅ Нужны как внедрённые зависимости, ТАК И runtime-данные
- ✅ Создание объектов с пользовательским вводом
- ✅ ViewHolder'ы с зависимостями
- ✅ Worker'ы с зависимостями (Hilt 2.31+)
- ✅ Объекты с callback'ами

**Ключевые аннотации:**
- `@AssistedInject` — аннотация конструктора
- `@Assisted` — аннотация параметра для runtime-данных
- `@AssistedFactory` — интерфейс factory
- `@Assisted("name")` — именованные параметры для различения

**Преимущества:**
- Чёткое разделение внедрённых и runtime-параметров
- Типобезопасная генерация factory
- Сохранение преимуществ DI при принятии runtime-данных
- Нет boilerplate-реализации factory

**Лучшие практики:**
1. Используйте именованные @Assisted для параметров одного типа
2. Держите assisted-параметры минимальными
3. Внедряйте factory, а не класс напрямую
4. Тестируйте с fake-реализациями factory
