---
id: "20251015082237332"
title: "View Binding / Привязка View"
topic: android
difficulty: medium
status: draft
created: 2025-10-15
tags: - android
  - view-binding
  - ui
  - type-safety
  - difficulty/medium
source: https://github.com/Kirchhoff-/Android-Interview-Questions/blob/master/Android/What%20do%20you%20know%20about%20View%20Binding.md
subtopics:   - ui-views
  - gradle
  - build-variants
---
# View Binding in Android / View Binding в Android

**English**: What do you know about View Binding?

**Russian**: Что вы знаете о View Binding?

## Answer (EN)
View binding is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a `binding class` for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.

In most cases, view binding replaces `findViewById`.

## Setup instructions

View binding is enabled on a module by module basis. To enable view binding in a module, set the `viewBinding` build option to `true` in the module-level `build.gradle` file, as shown in the following example:

```gradle
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
```

## Usage

If view binding is enabled for a module, a binding class is generated for each XML layout file that the module contains. Each binding class contains references to the root view and all views that have an ID. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end.

For example, given a layout file called `result_profile.xml`:

```xml
<LinearLayout ... >
    <TextView android:id="@+id/name" />
    <ImageView android:cropToPadding="true" />
    <Button android:id="@+id/button"
        android:background="@drawable/rounded_button" />
</LinearLayout>
```

The generated binding class is called `ResultProfileBinding`. This class has two fields: a `TextView` called `name` and a `Button` called `button`. The `ImageView` in the layout has no ID, so there is no reference to it in the binding class.

Every binding class also includes a `getRoot()` method, providing a direct reference for the root view of the corresponding layout file. In this example, the `getRoot()` method in the `ResultProfileBinding` class returns the `LinearLayout` root view.

## Use view binding in activities

To set up an instance of the binding class for use with an activity, perform the following steps in the activity's `onCreate()` method:

- Call the static `inflate()` method included in the generated binding class. This creates an instance of the binding class for the activity to use;
- Get a reference to the root view by either calling the `getRoot()` method or using Kotlin property syntax.
- Pass the root view to `setContentView()` to make it the active view on the screen.

```kotlin
private lateinit var binding: ResultProfileBinding

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = ResultProfileBinding.inflate(layoutInflater)
    val view = binding.root
    setContentView(view)
}
```

You can now use the instance of the binding class to reference any of the views:

```kotlin
binding.name.text = viewModel.name
binding.button.setOnClickListener { viewModel.userClicked() }
```

## Use view binding in fragments

To set up an instance of the binding class for use with a fragment, perform the following steps in the fragment's `onCreateView()` method:

- Call the static `inflate()` method included in the generated binding class. This creates an instance of the binding class for the fragment to use;
- Get a reference to the root view by either calling the `getRoot()` method or using Kotlin property syntax;
- Return the root view from the `onCreateView()` method to make it the active view on the screen.

```kotlin
private var _binding: ResultProfileBinding? = null
// This property is only valid between onCreateView and
// onDestroyView.
private val binding get() = _binding!!

override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View? {
    _binding = ResultProfileBinding.inflate(inflater, container, false)
    val view = binding.root
    return view
}

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
```

You can now use the instance of the binding class to reference any of the views:

```kotlin
binding.name.text = viewModel.name
binding.button.setOnClickListener { viewModel.userClicked() }
```

**Note**: Fragments outlive their views. Make sure you clean up any references to the binding class instance in the fragment's `onDestroyView()` method.

## Differences from findViewById

View binding has important advantages over using `findViewById`:

- **Null safety**: Since view binding creates direct references to views, there's no risk of a null pointer exception due to an invalid view ID. Additionally, when a view is only present in some configurations of a layout, the field containing its reference in the binding class is marked with `@Nullable`.
- **Type safety**: The fields in each binding class have types matching the views they reference in the XML file. This means that there's no risk of a class cast exception.

## Ответ (RU)
View binding - это функция, которая позволяет легче писать код, взаимодействующий с представлениями. После включения view binding в модуле, генерируется `класс привязки` для каждого XML файла макета, присутствующего в этом модуле. Экземпляр класса привязки содержит прямые ссылки на все представления с ID в соответствующем макете.

В большинстве случаев view binding заменяет `findViewById`.

### Настройка

View binding включается на уровне модуля. Чтобы включить view binding в модуле, установите опцию сборки `viewBinding` в `true` в файле `build.gradle` на уровне модуля:

```gradle
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
```

### Использование

Если view binding включен для модуля, для каждого XML файла макета генерируется класс привязки. Каждый класс привязки содержит ссылки на корневое представление и все представления с ID. Имя класса привязки генерируется путем преобразования имени XML файла в Pascal case и добавления слова "Binding" в конце.

Например, для файла макета `result_profile.xml`:

```xml
<LinearLayout ... >
    <TextView android:id="@+id/name" />
    <ImageView android:cropToPadding="true" />
    <Button android:id="@+id/button"
        android:background="@drawable/rounded_button" />
</LinearLayout>
```

Сгенерированный класс привязки называется `ResultProfileBinding`. Этот класс имеет два поля: `TextView` с именем `name` и `Button` с именем `button`. `ImageView` в макете не имеет ID, поэтому ссылки на него в классе привязки нет.

### Использование в Activity

```kotlin
private lateinit var binding: ResultProfileBinding

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = ResultProfileBinding.inflate(layoutInflater)
    val view = binding.root
    setContentView(view)
}
```

Теперь можно использовать экземпляр класса привязки для обращения к любым представлениям:

```kotlin
binding.name.text = viewModel.name
binding.button.setOnClickListener { viewModel.userClicked() }
```

### Использование во Fragments

```kotlin
private var _binding: ResultProfileBinding? = null
private val binding get() = _binding!!

override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View? {
    _binding = ResultProfileBinding.inflate(inflater, container, false)
    return binding.root
}

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
```

**Важно**: Фрагменты переживают свои представления. Убедитесь, что очищаете все ссылки на экземпляр класса привязки в методе `onDestroyView()` фрагмента.

### Преимущества перед findViewById

View binding имеет важные преимущества перед использованием `findViewById`:

- **Null безопасность**: Поскольку view binding создает прямые ссылки на представления, нет риска исключения null pointer из-за недействительного ID представления. Кроме того, когда представление присутствует только в некоторых конфигурациях макета, поле, содержащее его ссылку в классе привязки, помечается как `@Nullable`.
- **Типобезопасность**: Поля в каждом классе привязки имеют типы, соответствующие представлениям, на которые они ссылаются в XML файле. Это означает, что нет риска исключения class cast.

## Links

- [View Binding](https://developer.android.com/topic/libraries/view-binding)
- [View Binding Sample](https://github.com/android/architecture-components-samples/tree/main/ViewBindingSample)
- [Use view binding to replace findViewById](https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc)
- [Android Jetpack: Replace findViewById with view binding](https://www.youtube.com/watch?v=W7uujFrljW0)

---

## Related Questions

### Prerequisites (Easier)
- [[q-recyclerview-sethasfixedsize--android--easy]] - View
- [[q-viewmodel-pattern--android--easy]] - View

### Related (Medium)
- [[q-what-is-known-about-methods-that-redraw-view--android--medium]] - View
- [[q-testing-viewmodels-turbine--testing--medium]] - View
- [[q-rxjava-pagination-recyclerview--android--medium]] - View
- [[q-what-is-viewmodel--android--medium]] - View
- [[q-how-to-create-list-like-recyclerview-in-compose--android--medium]] - View

### Advanced (Harder)
- [[q-compose-custom-layout--jetpack-compose--hard]] - View
