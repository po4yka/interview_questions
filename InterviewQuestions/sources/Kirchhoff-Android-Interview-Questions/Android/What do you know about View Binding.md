# View Binding
View binding is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a `binding class` for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.

In most cases, view binding replaces `findViewById`.

# [Setup instructions](https://developer.android.com/topic/libraries/view-binding#setup)
View binding is enabled on a module by module basis. To enable view binding in a module, set the `viewBinding` build option to `true` in the module-level `build.gradle` file, as shown in the following example:

```
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
```

# [Usage](https://developer.android.com/topic/libraries/view-binding#usage)
If view binding is enabled for a module, a binding class is generated for each XML layout file that the module contains. Each binding class contains references to the root view and all views that have an ID. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end.

For example, given a layout file called `result_profile.xml`:
```
<LinearLayout ... >
    <TextView android:id="@+id/name" />
    <ImageView android:cropToPadding="true" />
    <Button android:id="@+id/button"
        android:background="@drawable/rounded_button" />
</LinearLayout>
```

The generated binding class is called `ResultProfileBinding`. This class has two fields: a `TextView` called `name` and a `Button` called `button`. The `ImageView` in the layout has no ID, so there is no reference to it in the binding class.

Every binding class also includes a `getRoot()` method, providing a direct reference for the root view of the corresponding layout file. In this example, the `getRoot()` method in the `ResultProfileBinding` class returns the `LinearLayout` root view.

# [Use view binding in activities](https://developer.android.com/topic/libraries/view-binding#activities)
To set up an instance of the binding class for use with an activity, perform the following steps in the activity's `onCreate()` method:
- Call the static `inflate()` method included in the generated binding class. This creates an instance of the binding class for the activity to use;
- Get a reference to the root view by either calling the `getRoot()` method or using Kotlin property syntax.
- Pass the root view to `setContentView()` to make it the active view on the screen.

```
private lateinit var binding: ResultProfileBinding

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = ResultProfileBinding.inflate(layoutInflater)
    val view = binding.root
    setContentView(view)
}
```

You can now use the instance of the binding class to reference any of the views:
```
binding.name.text = viewModel.name
binding.button.setOnClickListener { viewModel.userClicked() }
```

# [Use view binding in fragments](https://developer.android.com/topic/libraries/view-binding#fragments)
To set up an instance of the binding class for use with a fragment, perform the following steps in the fragment's `onCreateView()` method:
- Call the static `inflate()` method included in the generated binding class. This creates an instance of the binding class for the fragment to use;
- Get a reference to the root view by either calling the `getRoot()` method or using Kotlin property syntax;
- Return the root view from the `onCreateView()` method to make it the active view on the screen.

```
private var _binding: ResultProfileBinding? = null
// This property is only valid between onCreateView and
// onDestroyView.
private val binding get() = _binding!!

override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View? {
    _binding = ResultProfileBinding.inflate(inflater, container, false)
    val view = binding.root
    return view
}

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
```

You can now use the instance of the binding class to reference any of the views:
```
binding.name.text = viewModel.name
binding.button.setOnClickListener { viewModel.userClicked() }
```

**Note**: Note: Fragments outlive their views. Make sure you clean up any references to the binding class instance in the fragment's `onDestroyView()` method.

# [Differences from findViewById](https://developer.android.com/topic/libraries/view-binding#findviewbyid)
View binding has important advantages over using `findViewById`:
- **Null safety**: Since view binding creates direct references to views, there's no risk of a null pointer exception due to an invalid view ID. Additionally, when a view is only present in some configurations of a layout, the field containing its reference in the binding class is marked with `@Nullable`.
- **Type safety**: The fields in each binding class have types matching the views they reference in the XML file. This means that there's no risk of a class cast exception.

# Links
[View Binding](https://developer.android.com/topic/libraries/view-binding)

# Further reading
[View Binding Sample](https://github.com/android/architecture-components-samples/tree/main/ViewBindingSample)

[Use view binding to replace findViewById](https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc)

[Android Jetpack: Replace findViewById with view binding](https://www.youtube.com/watch?v=W7uujFrljW0)

# Next questions
[What is the difference between view binding and data binding](https://github.com/Kirchhoff-/Android-Interview-Questions/blob/master/Android/What%20is%20the%20difference%20between%20view%20binding%20and%20data%20binding.md)
