"""Data models for the Anki ingestion workflow."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import date
from typing import Iterable, Sequence


@dataclass(slots=True)
class SourceInfo:
    """Reference to an external source used to build a note."""

    url: str
    note: str | None = None


@dataclass(slots=True)
class GeneratedCard:
    """Structured representation of a bilingual Q&A pair generated by the agent."""

    slug: str
    topic: str
    difficulty: str
    question_kind: str
    title_en: str
    title_ru: str
    question_en: str
    question_ru: str
    answer_en: str
    answer_ru: str
    follow_ups_en: list[str] = field(default_factory=list)
    follow_ups_ru: list[str] = field(default_factory=list)
    subtopics: list[str] = field(default_factory=list)
    tags: list[str] = field(default_factory=list)
    aliases: list[str] = field(default_factory=list)
    related: list[str] = field(default_factory=list)
    sources: list[SourceInfo] = field(default_factory=list)
    original_language: str = "ru"

    def all_follow_ups(self) -> list[tuple[str, Sequence[str]]]:
        """Return bilingual follow-up questions ready for rendering."""

        pairs: list[tuple[str, Sequence[str]]] = []
        if self.follow_ups_ru:
            pairs.append(("ru", tuple(self.follow_ups_ru)))
        if self.follow_ups_en:
            pairs.append(("en", tuple(self.follow_ups_en)))
        return pairs

    def ensure_required_defaults(self, *, article_url: str) -> None:
        """Fill in required defaults that the LLM might omit."""

        if not self.original_language:
            self.original_language = "ru"
        if not self.sources:
            self.sources = [SourceInfo(url=article_url, note="Source article")]
        if not any(tag.startswith("difficulty/") for tag in self.tags):
            self.tags.append(f"difficulty/{self.difficulty.lower()}")
        if "lang/ru" not in self.tags:
            self.tags.append("lang/ru")
        if "lang/en" not in self.tags:
            self.tags.append("lang/en")
        if not self.aliases:
            aliases: list[str] = []
            if self.title_en:
                aliases.append(self.title_en)
            if self.title_ru:
                aliases.append(self.title_ru)
            self.aliases = aliases
        cleaned_tags = [_normalize_tag(tag) for tag in self.tags]
        self.tags = [tag for tag in _unique_sequence(cleaned_tags) if tag]
        self.subtopics = _unique_sequence(tag.strip() for tag in self.subtopics if tag.strip())
        self.aliases = _unique_sequence(alias.strip() for alias in self.aliases if alias.strip())
        self.related = _unique_sequence(item.strip() for item in self.related if item.strip())
        if not self.sources:
            self.sources = [SourceInfo(url=article_url)]


@dataclass(slots=True)
class WorkflowResult:
    """Outcome of the ingestion workflow."""

    article_url: str
    article_text: str
    generated_cards: list[GeneratedCard]
    created_paths: list[str]
    skipped_duplicates: list[str]
    run_date: date


def _unique_sequence(values: Iterable[str]) -> list[str]:
    seen: set[str] = set()
    unique: list[str] = []
    for value in values:
        if value not in seen:
            seen.add(value)
            unique.append(value)
    return unique


def _normalize_tag(tag: str) -> str:
    normalized = tag.strip().lower().replace(" ", "-")
    if not normalized:
        return ""
    if any(ord(ch) > 127 for ch in normalized):
        return ""
    return normalized
